# 3주차 스터디

##

### Exhaustive search(완전탐색)

가장 기본적인 알고리즘. 컴퓨터의 연산능력에 의존하여 모든 경우의 수를 고려하며 가능한 방법을 모두 찾아 해를 찾는다. 다양한 경우에서 사용되어 다양한 방법으로 구현된다.

- _Brute Force_
  for, if문으로 문제상황에서 모든 경우를 탐색

- _비트마스크_
  완전탐색을 구현하는데 사용되는 테크닉 중 하나로 이진수 표현을 활용해 메모리와 속도에 이점을 가진 기법이다.
  배열이나 집합의 원소를 비트로 마스크를 씌워 간결한 연산으로 배열의 집합고 연산을 표현할 수 있다.

  ```python
  # 삽입 : OR 연산으로 구현
  10101 | 1 << 3  # == 11101|01000

  # 삭제 : AND NOT 연산 활용
  11101 | ~1 << 3  # == 11101|10111

  # 조회 : AND 연산으로 구현
  10101 & 1 << 3  # 3번째 비트값 조회
  ```

- _순열 조합_
  문제 상황에 따라 순열과 조합의 개념이 사용되기도 함. Python에서 itertools 라이브러리로 순열과 조합을 지원한다. 순열과 조합은 <a href="https://medium.com/@dltkddud4403/python-%EC%88%9C%EC%97%B4-%EC%A1%B0%ED%95%A9-%EA%B5%AC%ED%98%84-5e496e74621c">재귀함수나 dfs, bfs</a>를 통해 구할 수도 있다.

  ```python
  >>> from itertools import combinations, permutations, product
  >>> a = [1,2,3]
  >>> b = ['a','b']
  >>> list(combinations(a, 2)) # 조합
  [(1, 2), (1, 3), (2, 3)]
  >>> list(permutations(a, 3)) # 순열
  [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]
  >>> list(product(a)) # 곱집합(Cartesian Product)
  [(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b'), (3, 'a'), (3, 'b')]
  ```

- 백트래킹
  조건만족문제를 풀기 위해 고안된 알고리즘으로 조건을 만족할 경우에 모든 경우를 탐색하는 알고리즘이다. 모든 경우의 수를 찾는 것이 아니고 조건에 부합하는 경우만 탐색하기에 기존의 완전탐색보다 빠르다.
  문제를 풀때 가능한 경우가 없으면 그 직전의 상태로 돌아가서 다른 경우를 탐색하기에 백트래킹이라는 이름이 붙여졌다. 메모리 문제로 보통 BFS보다 DFS로 구현되며 DFS는 완전탐색이 기반이지만 백트래킹은 가지치기를 통해 합리적인 해를 찾는 알고리즘이다. 사실상 당연한 이야기...

- BFS, DFS
  그래프 자료구조에서 사용되는 알고리즘. 차례로 넓이 우선 탐색, 깊이 우선 탐색이라고 한다. 방문여부를 체크하여 완전탐색이 끝날 때까지 재귀로 반복. BFS는 루트로 부터 깊이가 짧은 노드부터 탐색하고 DFS는 제일 깊이 있는 노드로 접근하여 뒤돌아 나오면서 탐색한다. 추후 깊이 공부.

##

### Greedy

---

#### <a href="https://programmers.co.kr/learn/courses/30/parts/12230">BruteForce 문제</a>

#### <a href="https://programmers.co.kr/learn/courses/30/parts/12244">Greedy 문제</a>
